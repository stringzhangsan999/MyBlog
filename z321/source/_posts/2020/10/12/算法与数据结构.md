---
title: 算法中的时间复杂度和空间复杂度介绍
date: 2020-10-12 11:57:08
tags: 算法
categories: 算法和数据结构
description: 描述算法中的时间空间复杂度以及计算
---

# 算法的时间复杂度

##  度量一个程序(算法)执行时间的两种方法

**<font color='red'>注意：时间复杂度并不是说程序的耗时有多久 而只是在时间上的一个度量</font>**

1. > 事后统计的方法
   >
   >   这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, <font color='cornflowerblue'>这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</font>

2. > 事前估算的方法
   >
   >   通过分析某个算法的<font color='red'>时间复杂度</font>来判断哪个算法更优.

## 时间频度

+ 基本介绍

> 时间频度：
>
> ​    一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。

[举例说明]-基本案例
比如计算1-100所有数字之和, 我们设计两种算法：

{%asset_img for.jpg 使用for循环%}

T（n）= n+1;

{%asset_img one.jpg 使用一条语句直接计算%}

T   (n)   = 1 

## 如何计算最终程序的时间复杂度

**[举例说明]-忽略常数项**

{%asset_img overlooknum1.jpg 统计数据表%}{%asset_img overlooknum2.jpg 统计数据图%}

结论: 

1. 2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略
2. 3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略

**[举例说明]-忽略低次项**

{%asset_img overlookcixiang1.jpg 统计数据表%}

{%asset_img overlookcixiang2.jpg 统计数据图%}

结论: 

1. 2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10
2. n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20

**[举例说明]-忽略系数**

{%asset_img overlookxishu1.jpg 统计数据表%}

{%asset_img overlookxishu2.jpg 统计数据图%}

结论: 

1. 随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明  这种情况下, 5和3可以忽略。
2. 而n^3+5n 和 6n^3+4n  ，执行曲线分离，说明多少次方式关键

立方不可以忽略系数可以发现当n越来越大那么将会出现1:6的结果



## 最后时间复杂度计算步骤如下

1. 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度。
2. T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。
3. 计算时间复杂度的方法：
   

+ 用常数1代替运行时间中的所有加法常数  T(n)=n²+7n+6  => T(n)=n²+7n+1
+ 修改后的运行次数函数中，只保留最高阶项  T(n)=n²+7n+1 => T(n) = n²
+ 去除最高阶项的系数 T(n) = n² => T(n) = n² => O(n²)

## 常见的时间复杂度

**从优到差依次排序：**

1. 常数阶O(1)
2. 对数阶O(log2n)
3. 线性阶O(n)
4. 线性对数阶O(nlog2n)
5. 平方阶O(n^2)
6. 立方阶O(n^3)
7. k次方阶O(n^k)
8. 指数阶O(2^n)

{%asset_img time1.jpg 时间复杂度的排行%}



**说明：**

+ 常见的算法时间复杂度由小到大依次为：**Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk次方) ＜Ο(2n) ，**随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低
+ 从图中可见，我们应该尽可能避免使用指数阶的算法

## 常见空间复杂度举例

1. **时间复杂度 常数阶O(1)**

​    无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)

{%asset_img timehard1.jpg 常数阶%}

>    上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

2. **时间复杂度 对数阶O(log2n)**

{%asset_img timehard2.jpg 对数阶%}

说明：

> ​    在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)  。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) .

3. 时间复杂度 线性阶O(n)

{%asset_img timehard3.jpg 线性阶%}

说明：

> ​    这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度

4. 时间复杂度 线性对数阶O(nlogN)

{%asset_img timehard4.jpg 线性对数阶%}

说明：

>线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)

5. 时间复杂度 平方阶O(n²) 

{%asset_img timehard5.jpg 平方阶%}

说明：

> ​    平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即  O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m\*n)

# 算法的空间复杂度

​    既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，**<font color='red'>空间复杂度也不是用来计算程序实际占用的空间的</font>**。

​    空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。

   空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看： 

1. **空间复杂度 O(1)**

      如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1) 

   例如：

   ```java
   int i = 1;
   int j = 2;
   ++i;
   j++;
   int m = i + j;
   ```

      代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1) 

2. **空间复杂度 O(n)**

​        例如: 

```java
int [] array = new int [n];
int x = 0;
for(int i=0 ; i<n ; i++){
    x= array[i];
}
```



   这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n) 

3. 空间复杂度O(n²)

   同上所诉：

```java
int[][] arrays = new int[n][n]
int x = 0;
for(i=1; i<=n; i++)
{
  for(j=1; j<=n; j++){
     x=arrays[i][j]; 
  }
}
```



​    可以看出时间复杂度为O(n\*n) 空间复杂度为O(n\*n),因为除了前面创建了一个二维数组占用了空间以外其他的没有额外创建空间



